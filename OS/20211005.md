# 🙌 PCB (Process Control Block) & Context Switch (문맥 교환)

> 오늘은 매우매우 중요한 개념인 Context Switching에 대해 정리해보자.

### ✔ **PCB (Process Control Block)이란? (프로세스 제어 블록)** 

TCB(Task Control Block)이라고도 불리는 PCB는 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료 구조이다. 모든 프로세스는 고유의 PCB를 가지며, PCB는 프로세스 생성 시 만들어져서 프로세스가 실행을 완료하면 폐기된다. 

<br>

#### **PCB의 구성**
* 프로세스 상태 : 프로세스는 새로운(new), 준비(ready), 실행(running), 대기(waiting), 정지(halted) 상태 등이다.
* 프로그램 카운터 : 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
* CPU 레지스터 : CPU의 레지스터 정보와 상태코드 정보가 포함된다. 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.
* CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄의 매개변수 등
* 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보
* 회계  정보 : CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
* 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함

![image](https://user-images.githubusercontent.com/63777714/136078011-a5d99484-3580-43e9-b925-24b6dbfe06b3.png)


    즉, PCB는 프로세스를 시작 또는 재시작시키는 데 필요한 모든 데이터를 위한 저장소이다.


* * *
<br>

### ✔ **Context Switch (문맥교환)**
<br>

현재 CPU를 차지하던 프로세스의 정보를 문맥(context)이라고 한다. 문맥 교환(Context Switch)는 CPU가 현재 실행중인 프로세스A를 프로세스B로 교체하기 위해 프로세스A의 정보를 저장하고 프로세스B로 교체되는 작업을 말한다. 이 때 프로세스 A의 정보를 저장하는 곳과 프로세스 B의 정보를 읽어오는 곳이 PCB이다. 

<br>


하나의 CPU는 하나의 Task(프로세스)만 실행할 수 있다. 하지만 우리가 실제로 사용하기에 여러개의 프로그램을 틀어놔도 작동하는 것처럼 보이는 것은 빠른속도로 Task를 바꿔가며 실행하기 때문이다. 이를 가능하게 하기 위해선 CPU가 다른 프로세스로 교체될 때 이전 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이 작업을 문맥교환(Context Switch)라고 하며, 문맥 교환이 일어나면 과거 프로세스의 문맥(context)을 PCB에 저장하고, 새롭게 시작될 프로세스의 저장된 문맥(context)을 복구한다. 

<br>

#### **문맥 교환 흐름**

* P0 프로세스가 인터럽트되면서 PCB0에 P0 프로세스의 상태 정보를 저장
* 그 다음으로 실행할 P1 프로세스의 PCB1에서 P1 프로세스의 상태 정보를 읽어 CPU에 로딩
* P1 프로세스 실행
* P1 프로세스가 인터럽트되면서 PCB1에 P1 프로세스의 상태 정보를 저장
* 그 다음으로 실행할 P0 프로세스의 PCB0에서 P0 프로세스의 상태 정보가 CPU에 재로딩
* P0 프로세스 실행

![image](https://user-images.githubusercontent.com/63777714/136078062-374fd3d7-7a40-4f64-a5a5-8ddd14090854.png)

<br>

이와 같은 문맥 교환이 일어날 때 CPU는 아무런 일도 하지 않는다. 그냥 문맥 교환이 끝나기까지 기다리는 일만 한다. 즉, 문맥 교환이 발생하면 그만큼 많은 비용(Cost)가 소요된다는 것이다. 
<br>
* * *

### ✔ **Multi Process VS Multi Thread의 문맥교환**
<br>

**Multi Process**는 각 프로세스마다 독립된 메모리를 가지고 있다. 그렇기 때문에 문맥 교환이 일어나면 PCB에 저장하고 불러오는 메모리의 양이 많다. --> <u>먾은 비용 발생</u>

그에 비해 **Multi Thread**는 하나의 프로세스 안에서 스택 메모리 외에는 자원을 공유하고 있다. 이는 문맥 교환이 일어날 때 스택 메모리만 PCB에 저장하고 불러오면 된다는 것이다. 
--> <u>process에 비해 적은 비용 발생</u>

그렇기 때문에 문맥교환 비용은 Thread가 더 적게 든다. 


* * *

<br>

참고한 사이트
https://junhyunny.github.io/information/operating-system/process-control-block-and-context-switching/
