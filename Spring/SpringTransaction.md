# **[Spring] 트랜잭션 추상화**

<aside>

</aside>

## 💡 **트랜잭션이란?**

더 이상 나눌 수 없는 일련의 단위 작업을 뜻한다.

대표적인 예로 계좌이체를 많이 말한다. 

계좌이체를 예를 보면 다음과 같은 순서로 작업이 일어난다. 

1. 계좌이체하고자 하는 금액 입력
2. 계좌에 뽑고자하는 금액보다 많은 금액이 들어있는지 확인
3. 들어있다면 출금
4. 송금한 계좌에 입금된 만큼 +

---
## 💡 **ACID란?**

ACID는 트랜젝션의 특징들의 앞글자를 딴 단어이다.

### **Atomicity(원자성)**

트랜잭션을 구성하는 1~4번이 **모두 수행되거나 모두 수행되지 않아야 하는 특성**을 말한다.
이는 DB에 대해서 알아야 하는데 DB에서 자동으로 이전에 commit 된 상태를 임시 영역인 rollback segment 에 저장을 해놓고 장애가 발생할 떄 rollback segment 에 저장해놓았던 상태로 rollback을 하게 되는 것이다.

### **Consistency(일관성)**

트랜잭션이 **성공적으로 완료가 되었으면 일관적인 DB 상태를 유지**해야 한다는 것이다. 트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건을(기본키, 외래키, 도메인 등)을 만족하는 것을 통해 보장되어야 한다. 

데이터베이스 내의 계층관계, 컬럼의 데이터 속성 등이 항상 일관되게 유지되어야 한다. 

예를들어, 만약 데이터베이스의 속성이 수정되었다면 trigger를 통해 일괄적으로 모든 데이터데이스에 적용되어야 한다.

### **Durability(지속성)**

**한번 반영(커밋)된 트랜젝션의 내용은 영원히 적용되는 특성을 의미**한다.
시스템에 장애가 발생하더라도 트랜잭션이 성공적으로 완료되어 커밋까지 되었으면 작업결과는 데이터베이스에 그대로 반영이 되어있어야 합니다.

### **Isolation(독립성)**

**트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것이다**.

즉, 동시성 제어가 필요하다는 것이다. 

예를들면, 통장에 잔고가 5만원인 A에게 B와 C가 모두 1만원을 송금한다고 가정해보자. 

B와 C가 둘 다 1만원씩 보냈으니 A의 잔액은 7만원이 되어야 하지만 트랜잭션의 독립성이 보장되지 않는다면 동시에 접근했을 때 A의 잔액을 B와 C가 모두 5만원으로 조회를 해 둘 다 6만원으로 업데이트를 치는 경우가 발생할 수 있다. (날라가버린 만원)

트랜잭션은 격리 수준 설정을 통해서 독립성을 보장하고 있다. 

<aside>
🦼 무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다

</aside>

---

## 💡 **스프링에서의 트랜잭션 추상화**

스프링은 트랜잭션 기술의 공통점을 담는 트랜잭션 추상화 기술들을 제공하고 있다.

이를 이용하면 애플리케이션에서 직접 각 기술의 트랜잭션 API 를 이용하지 않고도, 일관된 방식으로 트랜잭션을 제어하는 트랜잭션 경계설정 작업이 가능해진다.

    기존의 트랜잭션을 서비스에서 이용하면 서비스에서 의존도가 발생하게 되어 OCP 를 제대로 지키지 못하게 된다. 

![image](https://user-images.githubusercontent.com/63777714/147813218-ac8851da-50be-48a3-9123-cedfee8d74b6.png)


`PlatformTransactionManager`

- `getTransaction`, `commit`, `rollback` 세 가지의 메소드를 가짐

`getTransaction()`의 파라미터인 `TransactionDefinition`

- 트랜잭션의 프로퍼티를 관리한다
- ex) 전파(propagation) , 타임아웃(timeout), 격리수준(isolation level), 읽기 속성 (read-only)

`TransactionStatus` 

- 트랜잭션의 실행 제어를 관리한 다른 트랜잭션 결과를 설정하거나 트랜잭션의 완성 여부나 새 트랜잭션인지의 여부를 확인하는 데 사용
- `PlatformTransactionManager.getTransaction(TransactionDefinition a)`을 통해 반환되는 값

```java
public interface TransactionStatus extends SavepointManager {

  boolean isNewTransaction();
  boolean hasSavepoint();
  void setRollbackOnly();
  boolean isRollbackOnly();
  void flush();
  boolean isCompleted();
}
```
---

## **Transaction 속성**

`getTransaciont()`의 파라미터인 `TransactionDefinition` —> 트랜잭션의 속성을 담고있는 정보

**1. 트랜잭션 전파**

- 트랜잭션 전파란 트랜잭션 경계에서 이미 진행 중인 트랜잭션이 있거나 없을 때 동작할 것인가를 결정하는 방식을 말한다. 트랜잭션 전파 속성으로는 다음과 같이 정의할 수 있다.
    - PROPAGATION_REQUIRED
        - 가장 많이 사용되는 전파 속성으로 진행중인 트랜잭션이 없으면 새로 시작하고 이미 시작된 트랜잭션이 있으면 이에 참여한다.
    - PROPAGATION_REQUIRES_NEW
        - 항상 새로운 트랜잭션을 시작한다.
        - 앞에서 시작된 트랜잭션이 있든 없은 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작하게 한다.
        - 트랜잭션 1이 실행되고 있는 도중에 해당 속성을 가진 트랜잭션 2가 실행되면 트랜잭션 1을 보류한 상태로 트랜잭션 2를 실행한다.
    - PROPAGATION_SUPPORTS
        - 진행중인 트랜잭션이 있을 경우 REQUIRED 처럼 참여하고, 트랜잭션이 없을 경우 트랜잭션 없이 메소드 실행한다.
    - PROPAGATION_NOT_SUPPORTED
        - 트랜잭션 없이 동작할 수 있도록 한다.
        - 진행중인 트랜잭션이 있어도 무시한다.

이 외에도 NEVER, NESTED 등 전파 속성이 있다.

**2. 격리수준(isolation)**

동시에 여러 트랜잭션이 실행될 경우 다른 트랜잭션에게 트랜잭션의 작업내역을 보여줄 지 말지를 결정하는 설정으로 가능하면 많은 트랜잭션을 동시에 진행시키면서 문제가 발생하지 않도록 하기 위해 격리수준 설정이 필요하다. 

- 기본적으로 DB에 설정이 되어있지만 재설정 할 수 있음
    - READ_UNCOMMITED (Level 0) : 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있음
    - READ_COMMITED (Level 1) : 커밋되지 않은 정보는 읽을 수 없음
    - REPEATABLE_READ(Level 2) : 하나의 트랜잭션이 읽은 row를 다른 트랜잭션이 수정할 수 없음
    - SERIALIZABLE(Level 3) : 이 속성을 가진 트랜잭션이 존재할 시 동시에 같은 테이블의 정보에 접근할 수 없음
    - DEFAULT : 사용하는 DB 기본 설정을 따른다.

**3. 제한 시간**

- 트랜잭션을 수행하는 제한시간을 설정할 수 있다.

**4. 읽기전용**

- 읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다.